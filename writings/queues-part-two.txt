In part one of this series, we showed you that queues are weird and don't conform to our intuitive expectations of how they will behave. They're weird because randomness is weird. Or to be more precise: when memoryless random events meet processes with cumulative effects, weird things happen. We also argued that queues are everywhere in software development, and so is randomness. In this part, we're going to talk about why long queues present problems and how we can practically avoid long queues. 
* Why are queues a problem in airport check-in?
Let's revisit our airport check-in queues. Why is it a problem if those queues get long? The longer the queues get, the more dissatisfied our customers get. Past a certain point, our queue becomes long enough that people arriving at the airport the recommended three hours before their flight cannot get checked in and through security to their gate in time. At this point, we need to have another member of staff walk through the queue, calling forward all the passengers for flights soon to depart for expedited check-in. At a certain point, if the queue is still growing, even expediting won't help us, and people will start missing their flights. If this happens too often, the airport ceases to function. So there is a cost to having people stand in line for longer, and that cost escalates and has inflection points where additional costs arise.
* Why are queues a problem in software development?
ANY STAGE GATE IS AN OPPORTUNITY FOR A QUEUE TO FORM. A SINGLE ITEM WAITING IS IN A QUEUE OF ONE

In software development, there are also direct costs to queues. The longer a product backlog becomes, the more maintenance it requires: is this story really still relevant? What does this comment from Eliza 18 months ago mean? Is that market research still valid? The longer feature requests wait in between someone asking for them and us deploying them to customers, the more people ask for status updates, and then someone has to find out about and report the status. The more _stuff_ I'm confronted with, the more effort I have to expend on determining what of that _stuff_ is the best thing for me to pick up next[1]. Those are the direct costs of having long queues. Some call them the carrying costs.

But there's also an indirect cost. We call it _cost of delay_. In the case of a product backlog item, its cost of delay is the amount of value that could be realized per day (hour, minute), for each day (hour, minute) that it is delayed and not moving through our process. To take a concrete example: we think that allowing users of our website to 'like' each others' posts will lead to a significant increase in their engagement, and hence (via advertising impressions) to our profits. Once the feature is finally deployed, our analysts tell us that we make 1000 additional dollars per hour. Unfortunately, there were various points in the development of this feature where it was in started, but waiting. After the PM, designer, and tech lead had drafted the 5 constituent stories, the engineers weren't ready to start working on it for another 4 weeks, because they were working on other things. For each story, there was a pull request which waited for code review for an average of 4 hours while potential reviewers worked on other things. After code review was complete, rework waited for an average of 2 hours per change while the engineer responsible was working on the next code change. And so on. Before long, we've amassed a huge amount of wait time. Maybe we only worked on this feature for one-person week, but it was waiting somewhere in our system for 5 weeks. And 5 weeks of $1000 per hour is a lot of cost.
* Cost of delay is a huge deal and grows if queues grow
* How do we avoid cost of delay approaching infinity (inability to innovate at all)?
	* avoid queues if possible - do you need an approval gate there?
	* make it sync as opposed to async (shift left on security, ops, code review)
	* but if you can't avoid the queue: reduce capacity utilization
* WTF is capacity utilization? GRAPH HERE - EXPLANATORY TEXT relates back to airline check-in agents - sometimes some people are idle and hence available to serve
* How do we reduce capacity utilization?
	* Hard to do it directly. For example, Scrum team could take 0.8 * Velocity as their commitment to next sprint, but it would require pretty good estimation to get this right. Being off by 20% on an estimate is pretty common. Plus the capacity is unknown ahead of time, because people might still be unavailable, so you need to account for that anyway. Not sure how you would do it for code review - available capacity for code review is much more elastic, because it's done by people who are doing other things.
	* BUT you can do it indirectly! WIP limits take advantage of the randomness to push down capacity utilization. INTERACTIVE HERE
	* The amazing thing about this is that _not only_ are we reducing our queue problem by taking advantage of the very problem that causes the issue -- randomness -- but _also_ we solve our queue problem by just... controlling the queue size.
* Why haven't I talked about controlling and reducing randomness? Six Sigma is a thing, right? We don't want things to be unpredictable.
	* Software is inherently unpredictable
	* The value of what we do is often in direct proportion to how novel -- and hence how unpredictable it is.
	* Even if we could, and even if we wanted to, reduce randomness, it wouldn't help us at high capacity utilization levels. GRAPH HERE
* OK, but how bad are queues really? I don't want people sitting idle.
	* Of course it's an optimization. Airline check-in economics are a bit different from software development economics. We're trading off cost of capacity vs cost of delay.
		* GRAPH HERE, PROBABLY SOME ABILITY TO TWEAK VARIABLES
	* The thing is: if you pay 0 cost of capacity, you eventually pay _infinite_ cost of delay. You can build new stuff for a while, but you'll get slower and slower, and eventually you have no ability to innovate and bring new stuff to the market in a timely fashion, so your competitors  eat your lunch. If you want to avoid this, you must introduce _some_ slack into the system. Things need to be idle at least some of the time so that there's an ability to deal with new information. You could crunch all the numbers and optimize to the nth degree, or you could just bear in mind that 80% is roughly toward the bottom end and shoot for that (or even better, apply WIP limits and let the randomness do it for you.)
* So in summary, what do I suggest you do?
	* Recognize the massive impact of cost of delay. Build it into your financial reporting if you can.
	* Whenever you see an opportunity for a queue to form, ask yourself: is it possible to avoid this queue? If I can't avoid the queue, can I make the asynchronous hand-off into a synchronous and blocking operation?
	* Where queues exist, reduce capacity utilization. Don't try to do it directly -- apply WIP limits. EXAMPLES OF WIP LIMITS HERE

1: I'm quite certain by now that there are readers who are practically screaming at me: "but queues in product development aren't like airport check-in queues! They're not first-in, first-out. We prioritize them." This is absolutely correct, and a full response to this is beyond the scope of this article. In lieu of a full response, I'll say some provocative things here and promise to follow up with a full examination later. First, it is unlikely you are prioritizing correctly. Second, prioritizing correctly only _mitigates_ the cost of queues. It doesn't solve it. Third, there is a cost to prioritizing which scales non-linearly with the size of the queue.
